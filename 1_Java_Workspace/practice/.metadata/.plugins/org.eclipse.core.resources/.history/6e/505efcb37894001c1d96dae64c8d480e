package com.kh.example.chap01_String.controller;

public class StringController {
	
	// String : 문자열 클래스
	// 문자열의 값 수정 불가(불변 클래스)
	// String name = "abc";
	// name = "def"; // <-수정된 거 아닌가? 수정된거 아님

	// 배열 크기 변경 불가능
	// 눈으로 보이기는 수정되는 것처럼 보이나 컴퓨터 안에 로직은 삭제 새로생성되었고 주소값도 변경됨
	// 값이 변경되는게 아니고 def가 새로 생성되고 abc가 지워져서 바꿔치기가 되는 것
	// 
	
	
	public void method1() {
		
		// String 만드는 방법 2가지
		// 방법1
		String str1 = "java";
		String str2 = "java";
		// 방법2
		String str3 = new String("java"); // String도 클라스 객체생성 방식으로 생성가능
		
		System.out.println("str1과 str2의 주소는  같은가? : "+(str1 == str2)); // ==은 주소값 비교 // 주소값 같다
		System.out.println("str1과 str3의 주소는  같은가? : "+(str1 == str3)); // 주소값 다르다
		
		// == : 주소값 비교, 기본형
		// .equals : 객체 자체값 비교, 참조형
		
		System.out.println(str1); // 결과값 java
		System.out.println(str2); // String = 참조형
		System.out.println(str3); 			// str3와 아래의 str3.toString은 같은 결과값을 낸다
		System.out.println(str3.toString());// 
		// toString : 객체에 대한 대표값을 반환
		
		// Q. new String(); 객체찍으면 여태까지 주소값이 나왔는데 왜 java라는 결과값이 나왔을까?
		// A. Object클래스의 toString을 오버라이딩 했기 때문에 주소값이 아닌 java가 뜬다
		// 위답의  Object클래스의 toString메소드가 아닌 String클래스의 toString메소드를 사용한다 
		
		// 참조변수.toString = 참조변수는 같은 결과값이 나옴
		// toString : 객체의 대표값을 반환
		// 그렇기에 객체만 찍어도 결과값이 잘나옴.
		
//		// hashCode()
//		주소값을 보기 위해 사용하는 코드
//		객체의 주소값을 해시코드로 구현한 결과값 
//
//		object클래스에 있음. 
//		실제 주소값을 직접 볼 수 있는건 아님.
//		자바는 애초에 주소값을 다이렉트로 볼 수 없게 만듬
		
		System.out.println("str1의 hashcode : "+str1.hashCode());
		System.out.println("str2의 hashcode : "+str2.hashCode());
		System.out.println("str3의 hashcode : "+str3.hashCode());
		
		// identityHashCode()
		// 실주소값을 연산해놓은 결과값을 도출하는 메소드
		System.out.println("str1의 실주소값 : "+System.identityHashCode(str1));
		System.out.println("str2의 실주소값 : "+System.identityHashCode(str2));
		System.out.println("str2의 실주소값 : "+System.identityHashCode(str3));
		System.out.println();
		
		str2 += "oracle"; // 결과값 : javaoracle
		System.out.println(str2);
		System.out.println("str1의 hashcode : "+str1.hashCode()); 			// hashCode()
		System.out.println("str2의 hashcode : "+str2.hashCode());
		System.out.println("str3의 hashcode : "+str3.hashCode());
		System.out.println("str1의 실주소값 : "+System.identityHashCode(str1)); // identityHashCode()
		System.out.println("str2의 실주소값 : "+System.identityHashCode(str2));
		System.out.println("str2의 실주소값 : "+System.identityHashCode(str3));
		
		
	}
	
	public void method2() {
		// StringBuffer & StringBuilder
		
		// 1) StringBuffer
		StringBuffer buffer1 = new StringBuffer();
		System.out.println("초기 buffer1의 수용량 : " +buffer1.capacity()); 		// StringBuffer에 기본생성자의 최초 capacity는 16으로 설정되어있음
		System.out.println("buffer1에 들어있는 실제 값의 길이 : " +buffer1.length()); // 수용량하고 실제값의 길이가 다르다
		
		System.out.println();
		
		StringBuffer buffer2 = new StringBuffer(100);   // StringBuffer 생성자는 int랑 str받는게 있다
		System.out.println("초기 buffer2의 수용량 : " +buffer2.capacity()); 		// 수용량 단위 : character 한문자임
		System.out.println("buffer2에 들어있는 실제 값의 길이 : " +buffer2.length()); //
		
		StringBuffer buffer3 = new StringBuffer("abc"); // StringBuffer 생성자는 int랑 str받는게 있다
		System.out.println("초기 buffer3의 수용량 : " +buffer3.capacity()); 		// 수용량 단위는 character 한문자이므로
		System.out.println("buffer3에 들어있는 실제 값의 길이 : " +buffer3.length()); //
		
		// 2) StringBuilder
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
}
